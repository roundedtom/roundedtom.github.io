{"title":"Golang学习笔记","markdown":{"yaml":{"title":"Golang学习笔记","author":"Tom","date":"2020-02-03","toc":true,"code-block-bg":true,"highlight-style":"zenburn","categories":["Golang"],"image":"golang.png","code-fold":false,"html-math-method":"katex","jupyter":"python3"},"headingText":"1 数组（array）","containsRefs":false,"markdown":"\n\n这篇博客记录 Golang 的学习笔记。\n\n\n- 数组是一组具有相同类型且长度固定的数据项序列\n- 数组是值类型\n\n## 1.1 数组的定义\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n    // 使用var关键字定义\n\tvar a1 [4]int\n\tfmt.Println(a1)\n    // ---> [0 0 0 0]\n\n\tvar a2 = [4]int{}\n\tfmt.Println(a2)\n    // ---> [0 0 0 0]\n\n    // 使用{}传入值\n\tvar a3 = [4]int{9, 5, 2, 7}\n\tfmt.Println(a3)\n    // ---> [9 5 2 7]\n\n    // 使用...，编译器会自动推断数组的长度\n\ta4 := [...]int{9, 5, 2, 7}\n\tfmt.Println(a4, len(a4), cap(a4))\n    // ---> [9 5 2 7] 4 4\n\n    // 使用：指明传入值的索引位置\n\ta5 := [...]string{1:\"Luffy\", 4:\"Hancock\"}\n\tfmt.Println(a5)\n    // ---> [ Luffy   Hancock]\n\n\ta5[0] = \"Nami\"\n\tfmt.Println(a5)\n    // ---> [Nami Luffy   Hancock]\n}\n```\n\n## 1.2 数组的访问\n\n数组通过下标索引来访问，语法与 python 类似。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\ta5 := [...]int{9, 5, 2, 7}\n\tfmt.Printf(\"%p, %v\\n\", &a5, a5)\n    // ---> 0xc0000ae000, [9 5 2 7]\n\n\ta5[0] = 100\n\tfmt.Printf(\"%p, %v\\n\", &a5, a5)\n    // ---> 0xc0000ae000, [100 5 2 7]\n}\n```\n\n## 1.3 数组的遍历\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\ta6 := [...]string {\"Luffy\", \"Zoro\", \"Hancock\", \"Nami\", \"Robin\"}\n\n\tfor i:=0; i<len(a6); i++ {\n\t\tfmt.Println(a6[i])\n\t}\n    // ---> Luffy\n\t// ---> Zoro\n\t// ---> Hancock\n\t// ---> Nami\n\t// ---> Robin\n\n\t// 使用range\n\tfor i,v := range a6 {\n\t\tfmt.Println(i, v)\n\t}\n    // ---> 0 Luffy\n\t// ---> 1 Zoro\n\t// ---> 2 Hancock\n\t// ---> 3 Nami\n\t// ---> 4 Robin\n}\n```\n\n## 1.4 多维数组\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\ta7 := [3][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}}\n\tfmt.Println(a7)\n\t// ---> [[1 2 3 4] [5 6 7 8] [9 10 11 12]]\n\n\ta8 := [2][3][4]int{\n\t\t{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}},\n\t\t{{13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24}},\n\t}\n\tfmt.Println(a8)\n    // ---> [[[1 2 3 4] [5 6 7 8] [9 10 11 12]]\n    // ---> [[13 14 15 16] [17 18 19 20] [21 22 23 24]]]\n}\n```\n\n# 2 切片（slice）\n\n- 切片是数组的抽象，本身不存储数据，而是存储底层数组的地址\n- 切片是引用类型\n- 切片是可变的\n\n## 2.1 切片的定义\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\n\tvar s1 []int\n    fmt.Printf(\"%T, %v\\n\", s1, s1)\n    fmt.Println(len(s1), cap(s1)) // 打印长度和容量\n\t// ---> []int, []\n\t// ---> 0 0\n\n    var s2 = []int{1, 2, 3, 4, 5}\n    fmt.Printf(\"%T, %v\\n\", s2, s2)\n    fmt.Println(len(s2), cap(s2))\n    // ---> []int, [1 2 3 4 5]\n\t// ---> 5 5\n\n    s3 := make([]int, 3, 5)\n    fmt.Println(s3, len(s3), cap(s3))\n    // ---> [0 0 0] 3 5\n}\n```\n\n## 2.2 切片的访问\n\n- 当向切片中添加数据时，若添加的数量总和超过切片的容量，切片会自动扩容，且容量成倍增加\n- 切片扩容本质是指向了一个新的数组，原来的数组被系统自动回收\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\n\ts1 := make([]int, 0, 4)\n\tfmt.Printf(\"%v, %p\\n\", s1, s1)\n\tfmt.Printf(\"length:%d, capacity:%d\\n\", len(s1), cap(s1))\n    // ---> [], 0xc0000b2000\n\t// ---> length:0, capacity:4\n\n\ts1 = append(s1, 1, 2)\n\tfmt.Printf(\"%v, %p\\n\", s1, s1)\n\tfmt.Printf(\"length:%d, capacity:%d\\n\", len(s1), cap(s1))\n\t// ---> [1 2], 0xc0000b2000\n    // ---> length:2, capacity:4\n    // 添加元素未超过容量，内存地址不变，依然是原来的数组\n\n\ts1 = append(s1, 3, 4, 5)\n\tfmt.Printf(\"%v, %p\\n\", s1, s1)\n\tfmt.Printf(\"length:%d, capacity:%d\\n\", len(s1), cap(s1))\n    // ---> [1 2 3 4 5], 0xc0000b6000\n    // ---> length:5, capacity:8\n    // 添加元素超过容量，切片指向新的数组，容量成倍增加\n\n}\n```\n\n从数组创建切片类似 python 的切片操作，使用 `[a:b]`，前闭后开。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\n\ts1 := [8]int{1, 2, 3, 4, 5, 6, 7, 8}\n\ts2 := s1[:]\n\tfmt.Printf(\"%v, %p， %p\\n\", s2, &s1, s2)\n\tfmt.Println(len(s2), cap(s2))\n    // ---> [1 2 3 4 5 6 7 8], 0xc0000ae000， 0xc0000ae000\n\t// ---> 8 8\n\n\ts3 := s1[0:3]\n\tfmt.Printf(\"%v, %p, %p\\n\", s3, &s1, s3)\n\tfmt.Println(len(s3), cap(s3))\n\t// ---> [1 2 3], 0xc0000ae000, 0xc0000ae000\n\t// ---> 3 8\n\n\ts4 := s1[3:6]\n\tfmt.Printf(\"%v, %p, %p\\n\", s4, &s1, s4)\n\tfmt.Println(len(s4), cap(s4))\n    // ---> [4 5 6], 0xc0000ae000, 0xc0000ae018\n\t// ---> 3 5\n    // 切片的长度即为截取的数组的长度，容量是从截取起始位置到数组末尾的长度\n    // 数组的地址是数组中首个元素的地址，s4由于截取的起始索引为3，所以s4的地址与s1不同\n}\n```\n\n切片本质上是一种特殊的指针，存储的是底层数组的地址。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\n\ts1 := [8]int{1, 2, 3, 4, 5, 6, 7, 8}\n\ts2 := s1[:6]\n\ts1[0] = 100\n\tfmt.Printf(\"%p, %p\\n\", &s1, s2)\n\tfmt.Println(s1, s2)\n\t// ---> 0xc00001e140, 0xc00001e140\n\t// ---> [100 2 3 4 5 6 7 8] [100 2 3 4 5 6]\n    // 切片指向底层数组，底层数组改变，切片相应改变\n\n\ts2[3] = 50\n\tfmt.Printf(\"%p, %p\\n\", &s1, s2)\n\tfmt.Println(s1, s2)\n    // ---> 0xc00001e140, 0xc00001e140\n\t// ---> [100 2 3 50 5 6 7 8] [100 2 3 50 5 6]\n    // 切片改变，也会导致底层数组改变\n\n\ts2 = append(s2, 25)\n\tfmt.Printf(\"%p, %p\\n\", &s1, s2)\n\tfmt.Println(s1, s2)\n    // ---> 0xc00001e140, 0xc00001e140\n    // ---> [100 2 3 50 5 6 25 8] [100 2 3 50 5 6 25]\n\n}\n\n```\n\n切片是引用类型。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\n\ts1 := []int{1, 2, 3, 4}\n\ts2 := s1\n\tfmt.Println(s1, s2)\n\tfmt.Printf(\"s1底层数组的地址:%p, s1的地址:%p\\n\", &s1, s1)\n\tfmt.Printf(\"s2底层数组的地址:%p, s2的地址:%p\\n\", &s2, s2)\n    // ---> [1 2 3 4] [1 2 3 4]\n\t// ---> s1底层数组的地址:0xc00000c060, s1的地址:0xc0000144a0\n\t// ---> s2底层数组的地址:0xc00000c080, s2的地址:0xc0000144a0\n    // s1，s2指向同一个底层数组\n\n\ts1[0] = 100\n\tfmt.Println(s1, s2)\n\tfmt.Printf(\"s1底层数组的地址:%p, s1的地址:%p\\n\", &s1, s1)\n\tfmt.Printf(\"s2底层数组的地址:%p, s2的地址:%p\\n\", &s2, s2)\n    // ---> [100 2 3 4] [100 2 3 4]\n\t// ---> s1底层数组的地址:0xc00000c060, s1的地址:0xc0000144a0\n\t// ---> s2底层数组的地址:0xc00000c080, s2的地址:0xc0000144a0\n    // 改变s1，s2同时也会改变\n\n\ts2[3] = 50\n\tfmt.Println(s1, s2)\n\tfmt.Printf(\"s1底层数组的地址:%p, s1的地址:%p\\n\", &s1, s1)\n\tfmt.Printf(\"s2底层数组的地址:%p, s2的地址:%p\\n\", &s2, s2)\n    // ---> [100 2 3 50] [100 2 3 50]\n\t// ---> s1底层数组的地址:0xc00000c060, s1的地址:0xc0000144a0\n\t// ---> s2底层数组的地址:0xc00000c080, s2的地址:0xc0000144a0\n\t// 改变s2，s1同时也会改变\n}\n```\n\n# 3 map\n\n- map 类似于 python 中的字典，也是以键值对的方式存储数据\n- map 是引用类型\n- map 是可变的\n\n## 3.1 map 的定义\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    var m1 map[string]int\n\tfmt.Printf(\"%T, %v\\n\", m1, m1)\n    // ---> map[string]int, map[]\n\t// 这种定义方式，m1并未初始化，是nil类型，不能直接赋值\n\tm1[\"Jay\"] = 1\n    // ---> panic: assignment to entry in nil map\n\n\tvar m2 = map[string]int{\"Jay\": 1, \"Edison\": 2, \"Luffy\": 3}\n\tfmt.Printf(\"%T, %v\\n\", m2, m2)\n    // ---> map[string]int, map[Edison:2 Jay:1 Luffy:3]\n\n\tm3 := map[string]int{\"Jay\": 1, \"Edison\": 2, \"Luffy\": 3}\n\tfmt.Printf(\"%T, %v\\n\", m3, m3)\n    // ---> map[string]int, map[Edison:2 Jay:1 Luffy:3]\n\n    // 使用make函数\n\tm4 := make(map[string]int)\n\tfmt.Printf(\"%T, %v\\n\", m4, m4)\n    // ---> map[string]int, map[]\n}\n```\n\n## 3.2 map 的访问\n\nmap 使用 key 进行访问与赋值\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n    m5 := make(map[int]string)\n\tm5[1] = \"Jay\"\n\tm5[2] = \"Edison\"\n\tm5[3] = \"Luffy\"\n\tm5[4] = \"Perl\"\n\tm5[5] = \"Mads\"\n\tm5[6] = \"Joker\"\n\tfmt.Println(m5)\n    // map[1:Jay 2:Edison 3:Luffy 4:Perl 5:Mads 6:Joker]\n\n\tfmt.Println(m5[3])\n    // Luffy\n}\n```\n\n## 3.3 map 的遍历\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n    m6 := map[string]string{\"name\":\"Luffy\", \"sex\":\"male\", \"age\":\"18\", \"address\":\"East blue\"}\n\tfor k,v := range m6 {\n\t\tfmt.Printf(\"%s : %s\\n\", k, v)\n\t}\n}\n// ---> name : Luffy\n// ---> sex : male\n// ---> age : 18\n// ---> address : East blue\n```\n\n# 4 指针（pointer)\n\n指针是一种特殊的变量，用于保存另一变量的内存地址。\n\n## 4.1 指针的定义\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar p1 *[4]int\n\tfmt.Println(p1)\n    // ---> <nil> // <nil>表示空指针\n\ta := [4]int{1, 2, 3, 4}\n\tp1 = &a // &为取地址符\n\tfmt.Println(p1)\n    // ---> &[1 2 3 4]\n\tfmt.Printf(\"%p, %p\\n\", p1, &p1) // 第一个占位符表示p1保存的地址，第二个占位符表示p1自身的地址\n    // ---> 0xc0000b0000, 0xc0000a8018\n}\n```\n\n## 4.2 指针的访问\n\ngo 语言中使用 \\* 来取指针所保存的内存地址指向的变量值。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar p2 *[4]string\n\ta2 := [4]string {\"Luffy\", \"Hancock\", \"Zoro\", \"Nami\"}\n\n\tp2 = &a2\n\tfmt.Println(*p2)\n    // ---> [Luffy Hancock Zoro Nami]\n\n\t(*p2)[0] = \"Robin\"\n\tfmt.Println(p2)\n    // ---> &[Robin Hancock Zoro Nami]\n\tfmt.Println(a2)\n    // ---> [Robin Hancock Zoro Nami]\n\n\tp2[2] = \"Shanks\" // 简化写法\n\tfmt.Println(p2)\n    // ---> &[Robin Hancock Shanks Nami]\n\tfmt.Println(a2)\n    // ---> [Robin Hancock Shanks Nami]\n\n}\n```\n\n## 4.3 指针的指针\n\n指针的指针，顾名思义，该指针中保存的是另一个指针的地址。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar ptr *[4]int\n\tvar pptr **[4]int\n\n\ta := [4]int{1, 2, 3, 4}\n\tptr = &a\n\tpptr = &ptr\n\n\tfmt.Println(a)\n    // ---> [1 2 3 4]\n\tfmt.Println(ptr, *ptr)\n    // ---> &[1 2 3 4] [1 2 3 4]\n\tfmt.Println(pptr, *pptr)\n    // ---> 0xc0000a8018 &[1 2 3 4]\n}\n```\n\n# 5 函数\n\n- 函数是一种特殊的指针变量\n- 函数名指向函数体的内存地址\n- 函数名加 `()` 调用函数，执行函数体内的全部代码，并通过 `return` 语句将执行结果返回给函数调用处\n\n## 5.1 函数的定义\n\n```go\nfunc funcName(p1 type, p2 type)(v1 type, v2 type) {\n    // 函数体\n    return v1, v2\n}\n\n// eg:\nfunc add(num1, num2 int)int {\n    return num1+num2\n}\n```\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Printf(\"%T, %p\\n\", print, print)\n    // ---> func(), 0x48eb50 // 函数体的地址\n\n\tvar x func()\n\tx = print // 将print的值（函数体的地址）赋值给x\n\tx()\n    // ---> Nami is alse good!\n}\n\nfunc print() {\n\tfmt.Println(\"Nami is alse good!\")\n}\n```\n\n## 5.2 函数的参数\n\n### 5.2.1 可变参数\n\n- 可变参数本质上是一个切片\n- 在参数列表中，可变参数应放在最后\n- 可变参数至多只能有一个\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tadd1()\n    // ---> []int\n    // 可变参数实质上是一个slice\n\n\ts := []int{1, 2, 3, 4, 5, 6}\n\tx := add2(s...) // 使用...提取slice中的元素\n\tfmt.Println(x)\n    // ---> 21\n}\n\nfunc add1(num ...int) {\n\tfmt.Printf(\"%T\\n\", num)\n}\n\nfunc add2(num ...int) int {\n\tsum := 0\n\tfor _, v := range num {\n\t\tsum = sum + v\n\t}\n\n\treturn sum\n}\n```\n\n### 5.2.2 参数传递\n\n**值传递**，值传递传递的是参数的副本。值类型的数据默认都是值传递：基本数据类型、array、struct。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tarr := [4]int{1, 2, 3, 4}\n\tfmt.Printf(\"%p, %v\\n\", &arr, arr)\n    // ---> 0xc0000ae000, [1 2 3 4]\n\n\tchange(arr)\n    // ---> 0xc0000ae060\n\t// ---> [10000 2 3 4]\n\n    fmt.Println(arr)\n    // ---> [1 2 3 4]\n}\n\nfunc change(a [4]int) {\n\tfmt.Printf(\"%p\\n\", &a)\n\ta[0] = 10000\n\tfmt.Println(a)\n}\n```\n\n**引用传递**，引用传递传递的是参数的地址。引用类型的数据默认都是引用传递：slice、map、chan。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tslice := []int{1, 2, 3, 4}\n\tfmt.Println(slice)\n\t// ---> [1 2 3 4]\n\n\tchange(slice)\n    // ---> [10000 2 3 4]\n\n\tfmt.Println(slice)\n    // ---> [10000 2 3 4]\n}\n\nfunc change(s []int) {\n\ts[0] = 10000\n\tfmt.Println(s)\n}\n```\n\n## 5.3 递归函数\n\n```go\nfunc fibonacci(n int) int {\n\tif n == 1 || n == 2 {\n\t\treturn 1\n\t}\n\treturn fibonacci(n-1) + fibonacci(n-2)\n}\n```\n\n## 5.4 defer 语句\n\n`defer` 语句可以用来延迟一个函数或者方法的执行。当存在多个延迟调用时，它们被添加到一个堆栈中，遵循后进先出的原则执行。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer print()\n\tdefer print2()\n\tfmt.Println(\"Hancock is good!\")\n    // ---> Hancock is good!\n    // ---> Robin is good! // LIFO\n    // ---> Nami is also good!\n}\n\nfunc print() {\n\tfmt.Println(\"Nami is also good!\")\n}\n\nfunc print2() {\n\tfmt.Println(\"Robin is good!\")\n}\n```\n\n## 5.5 匿名函数\n\n- 匿名函数可以作为另一个函数的参数，也叫回调函数\n- 匿名函数可以作为另一个函数的返回值，也叫闭包结构\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfunc () {\n\t\tfmt.Println(\"Hancock!\")\n\t}()\n    // ---> Hancock!\n\n\tfun1 := func () {\n\t\tfmt.Println(\"Nami!\")\n\t}\n\tfun1()\n    // ---> Nami!\n\n\t// 带参数与返回值的匿名函数\n\tres := func (a, b int) int {\n\t\treturn a+b\n\t}(1, 2)\n\tfmt.Println(res)\n    // ---> 3\n}\n```\n\n作为一个函数参数的函数就叫做回调函数。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tres := opr(1, 2, add)\n\tfmt.Println(res)\n    // ---> 3\n}\n\nfunc add(a, b int) int {\n\treturn a + b\n}\n\nfunc opr(a, b int, fun func(int,int)int) int {\n\treturn fun(a, b)\n}\n```\n\n使用匿名函数作为回调函数。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tadd := func(a, b int) int {\n\t\treturn a + b\n\t}\n\tres := opr(1, 2, add)\n\tfmt.Println(res)\n    // ---> 3\n\n\tres2 := opr(1, 2, func(a, b int) int {\n\t\treturn a + b\n\t})\n\tfmt.Println(res2)\n    // ---> 3\n}\n\nfunc opr(a, b int, fun func(int, int) int) int {\n\treturn fun(a, b)\n}\n```\n\n一个外层函数有内层函数，内层函数会操作外层函数的局部变量（外层函数的参数，或者外层函数定义的局部变量），并且该外层函数的返回值就是这个内层函数，那么这个内层函数和外层函数的局部变量就统称为闭包结构。\n\n闭包中局部变量的生命周期会发生改变。正常的局部变量会随着外层函数的调用而创建，随着外层函数的结束而销毁。但是闭包结构中外层函数的局部变量不会随着外层函数的结束而销毁，因为内层函数还要继续使用。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tfmt.Printf(\"%p\\n\", increment)\n    // ---> 0x48f0f0 // 函数名所指向的函数体的地址\n\tres1 := increment()\n\tfmt.Printf(\"%p, %p\\n\", res1, &res1)\n    // ---> 0x48f190, 0xc00000e030 // 内层函数体的地址， res1变量的地址\n\tfmt.Println(res1())\n    // ---> 1\n\tfmt.Println(res1())\n    // ---> 2\n\tfmt.Println(res1())\n    // ---> 3\n\n\tres2 := increment()\n\tfmt.Println(res2())\n    // ---> 1\n\tfmt.Println(res2())\n    // ---> 2\n\n\tfmt.Println(res1())\n    // ---> 4\n\n\tvar fun func() func() int\n\tfun = increment\n\tfmt.Printf(\"%p\\n\", fun)\n    // ---> 0x48f0f0\n\tfmt.Printf(\"%p\\n\", &fun)\n    // ---> 0xc00000e038\n\n\tfun2 := increment\n\tfmt.Printf(\"%p\\n\", fun2)\n    // ---> 0x48f0f0\n\tfmt.Printf(\"%p\\n\", &fun2)\n    // ---> 0xc00000e040\n\n}\n\nfunc increment() func() int {\n\ti := 0 //这个外层函数的局部变量，是内层函数的全局变量\n\treturn func() int {\n\t\ti++\n\t\treturn i\n\t}\n}\n```\n\n# 6 结构体\n\n- 结构体是一系列相同类型或不同类型的数据构成的集合\n- 结构体是由一个个成员变量构成的，这些成员变量也叫做结构体的字段\n- 结构体是可变的\n- 结构体是值类型\n\n## 6.1 结构体的定义\n\n```go\n// 结构体使用type和struct关键字来进行声明\ntype Person struct {\n    name string\n    sex string\n    age int\n    address string\n}\n```\n\n## 6.2 结构体的初始化与访问\n\n```go\n// 结构体使用.操作符来进行访问\n// 使用var关键字初始化\nvar P1 Person\np1.name = \"Jay\"\np1.sex = \"male\"\np1.age = \"41\"\np1.address = \"Taibei\"\n\n// 类似简短声明\np2 := Person{}\np2.name = \"Zoro\"\np2.sex = \"male\"\np2.age = \"20\"\np2.address = \"East Blue\"\n\n// 按照field:value的方式提供初始化的值\np3 := Person{\n    name ： \"Luffy\",\n    sex ： \"male\",\n    age ： 18,\n    address : \"East Blue\",\n}\n\n// 按照顺序提供初始化的值\np4 := Person{\"Hancock\", \"female\", 29, \"East Blue\"}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tp1 := Person{\n\t\tname:    \"Hancock\",\n\t\tsex:     \"female\",\n\t\tage:     29,\n\t\taddress: \"East Blue\",\n\t}\n\n\tfmt.Println(p1)\n    // ---> {Hancock female 29 East Blue}\n    // 结构体使用.操作符来进行访问\n\tp1.age = 31\n\tfmt.Println(p1)\n    // ---> {Hancock female 31 East Blue}\n}\n\ntype Person struct {\n\tname    string\n\tsex     string\n\tage     int\n\taddress string\n}\n```\n\n## 6.3 结构体指针\n\n```go\npackage main\n\nimport(\n\t\"fmt\"\n)\n\nfunc main() {\n\tp1 := Person {\n\t\tname : \"Hancock\",\n\t\tsex : \"female\",\n\t\tage : 29,\n\t\taddress : \"East Blue\",\n\t}\n\n\tvar pp1 *Person\n\tpp1 = &p1\n\tfmt.Printf(\"%p, %T\\n\", pp1, pp1)\n    // ---> 0xc0000240c0, *main.Person\n\tfmt.Println(*pp1)\n    // ---> {Hancock female 29 East Blue}\n\n\t// 使用指针修改数据\n\t(*pp1).name = \"Nami\"\n\tfmt.Println(pp1, p1)\n    // ---> &{Nami female 29 East Blue} {Nami female 29 East Blue}\n\t// 简写\n\tpp1.name = \"Robin\"\n\tfmt.Println(pp1, p1)\n    // ---> &{Robin female 29 East Blue} {Robin female 29 East Blue}\n\n    // 使用new函数创建指针\n    // new函数指向了新开辟的内存空间，里面存储的是0值\n    pp2 := new(Person)\n\tfmt.Printf(\"%T\\n\", pp2)\n    // ---> *main.Person\n\tfmt.Println(pp2)\n    // ---> &{  0 }\n\n\tpp2.name = \"Luffy\"\n\tpp2.sex = \"male\"\n\tpp2.age = 18\n\tpp2.address = \"East Blue\"\n\tfmt.Println(pp2)\n    // ---> &{Luffy male 18 East Blue}\n}\n\ntype Person struct {\n\tname string\n\tsex string\n\tage int\n\taddress string\n}\n```\n\n## 6.4 匿名结构体与匿名字段\n\n```go\npackage main\n\nimport(\n\t\"fmt\"\n)\n\nfunc main() {\n    // 匿名结构体\n\tp1 := struct {\n\t\tname string\n\t\tsex string\n\t\tage int\n\t\taddress string\n\t} {\n\t\tname : \"Hancock\",\n\t\tsex : \"female\",\n\t\tage : 29,\n\t\taddress : \"East Blue\",\n\t}\n\tfmt.Println(p1)\n    // ---> {Hancock female 29 East Blue}\n\n    // 结构体使用匿名字段时，默认使用字段类型作为field，因此字段类型不能重复\n\tp2 := Person {\"Hancock\", 29}\n\tfmt.Println(p2)\n\t// ---> {Hancock 29}\n\tfmt.Println(p2.string)\n    // ---> Hancock\n\n    // 同时使用匿名结构体和匿名字段\n\tp3 := struct {\n\t\tstring\n\t\tint\n\t} {\n\t\t\"Hancock\",\n\t\t29,\n\t}\n\tfmt.Println(p3)\n    // ---> {Hancock 29}\n\tfmt.Println(p3.string)\n    // ---> Hancock\n}\n\ntype Person struct {\n\tstring\n\tint\n}\n```\n\n## 6.5 结构体嵌套\n\n```go\npackage main\n\nimport(\n\t\"fmt\"\n)\n\nfunc main() {\n\tp1 := Person {\n\t\tname : Name {\n\t\t\tfirstName : \"Hancock\",\n\t\t\tlastName : \"Boa\",\n\t\t},\n\t\tsex : \"female\",\n\t\tage : 29,\n\t\taddress : \"East Blue\",\n\t}\n\n\tfmt.Printf(\"姓：%s，名：%s，性别：%s，年龄：%d，地址：%s\\n\", p1.name.lastName, p1.name.firstName, p1.sex, p1.age, p1.address)\n    // ---> 姓：Boa，名：Hancock，性别：female，年龄：29，地址：East Blue\n}\n\ntype Name struct {\n\tfirstName string\n\tlastName string\n}\n\ntype Person struct {\n\tname Name\n\tsex string\n\tage int\n\taddress string\n}\n```\n\n由于结构体是值类型，因此在嵌套时也可以选择嵌套结构体指针，可以保持数据的一致性，同时节省内存。\n\n```go\npackage main\n\nimport(\n\t\"fmt\"\n)\n\nfunc main() {\n\tn1 := Name {\n\t\tfirstName : \"Hancock\",\n\t\tlastName : \"Boa\",\n\t}\n\n\tp1 := Person {\n\t\tname : &n1,\n\t\tsex : \"female\",\n\t\tage : 29,\n\t\taddress : \"East Blue\",\n\t}\n\n\tfmt.Printf(\"姓：%s，名：%s，性别：%s，年龄：%d，地址：%s\\n\", p1.name.lastName, p1.name.firstName, p1.sex, p1.age, p1.address)\n    // ---> 姓：Boa，名：Hancock，性别：female，年龄：29，地址：East Blue\n\n\tp1.name.lastName = \"Monkey D\"\n\tfmt.Println(n1)\n    // 修改p1，n1同时改变，数据保持一致\n    // ---> {Hancock Monkey D}\n}\n\ntype Name struct {\n\tfirstName string\n\tlastName string\n}\n\ntype Person struct {\n\tname *Name // 传入指针\n\tsex string\n\tage int\n\taddress string\n}\n```\n\n假如说结构体中同时包含匿名字段与非匿名字段，特别的，当匿名字段为指针时，在实例化结构体时要给匿名字段加上字段名，且该字段名就是指针对应的类型，否则会报错 `mixture of field:value and value initializers` 。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\thancock := Person{\n\t\tname:   \"Hancock\",\n\t\tage:    29,\n\t\tgender: \"female\",\n\t}\n\tvar han *Person = &hancock\n\thanworker := Worker{\n\t\tPerson: han, // 要用指针对应的类型作为字段名\n\t\tskill:  \"bj\",\n\t\tsalary: 200,\n\t}\n\n\tfmt.Println(hanworker)\n}\n\ntype Person struct {\n\tname   string\n\tage    int\n\tgender string\n}\n\ntype Worker struct {\n\t*Person\n\tskill  string\n\tsalary int\n}\n```","srcMarkdownNoYaml":"\n\n这篇博客记录 Golang 的学习笔记。\n\n# 1 数组（array）\n\n- 数组是一组具有相同类型且长度固定的数据项序列\n- 数组是值类型\n\n## 1.1 数组的定义\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n    // 使用var关键字定义\n\tvar a1 [4]int\n\tfmt.Println(a1)\n    // ---> [0 0 0 0]\n\n\tvar a2 = [4]int{}\n\tfmt.Println(a2)\n    // ---> [0 0 0 0]\n\n    // 使用{}传入值\n\tvar a3 = [4]int{9, 5, 2, 7}\n\tfmt.Println(a3)\n    // ---> [9 5 2 7]\n\n    // 使用...，编译器会自动推断数组的长度\n\ta4 := [...]int{9, 5, 2, 7}\n\tfmt.Println(a4, len(a4), cap(a4))\n    // ---> [9 5 2 7] 4 4\n\n    // 使用：指明传入值的索引位置\n\ta5 := [...]string{1:\"Luffy\", 4:\"Hancock\"}\n\tfmt.Println(a5)\n    // ---> [ Luffy   Hancock]\n\n\ta5[0] = \"Nami\"\n\tfmt.Println(a5)\n    // ---> [Nami Luffy   Hancock]\n}\n```\n\n## 1.2 数组的访问\n\n数组通过下标索引来访问，语法与 python 类似。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\ta5 := [...]int{9, 5, 2, 7}\n\tfmt.Printf(\"%p, %v\\n\", &a5, a5)\n    // ---> 0xc0000ae000, [9 5 2 7]\n\n\ta5[0] = 100\n\tfmt.Printf(\"%p, %v\\n\", &a5, a5)\n    // ---> 0xc0000ae000, [100 5 2 7]\n}\n```\n\n## 1.3 数组的遍历\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\ta6 := [...]string {\"Luffy\", \"Zoro\", \"Hancock\", \"Nami\", \"Robin\"}\n\n\tfor i:=0; i<len(a6); i++ {\n\t\tfmt.Println(a6[i])\n\t}\n    // ---> Luffy\n\t// ---> Zoro\n\t// ---> Hancock\n\t// ---> Nami\n\t// ---> Robin\n\n\t// 使用range\n\tfor i,v := range a6 {\n\t\tfmt.Println(i, v)\n\t}\n    // ---> 0 Luffy\n\t// ---> 1 Zoro\n\t// ---> 2 Hancock\n\t// ---> 3 Nami\n\t// ---> 4 Robin\n}\n```\n\n## 1.4 多维数组\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\ta7 := [3][4]int{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}}\n\tfmt.Println(a7)\n\t// ---> [[1 2 3 4] [5 6 7 8] [9 10 11 12]]\n\n\ta8 := [2][3][4]int{\n\t\t{{1, 2, 3, 4}, {5, 6, 7, 8}, {9, 10, 11, 12}},\n\t\t{{13, 14, 15, 16}, {17, 18, 19, 20}, {21, 22, 23, 24}},\n\t}\n\tfmt.Println(a8)\n    // ---> [[[1 2 3 4] [5 6 7 8] [9 10 11 12]]\n    // ---> [[13 14 15 16] [17 18 19 20] [21 22 23 24]]]\n}\n```\n\n# 2 切片（slice）\n\n- 切片是数组的抽象，本身不存储数据，而是存储底层数组的地址\n- 切片是引用类型\n- 切片是可变的\n\n## 2.1 切片的定义\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\n\tvar s1 []int\n    fmt.Printf(\"%T, %v\\n\", s1, s1)\n    fmt.Println(len(s1), cap(s1)) // 打印长度和容量\n\t// ---> []int, []\n\t// ---> 0 0\n\n    var s2 = []int{1, 2, 3, 4, 5}\n    fmt.Printf(\"%T, %v\\n\", s2, s2)\n    fmt.Println(len(s2), cap(s2))\n    // ---> []int, [1 2 3 4 5]\n\t// ---> 5 5\n\n    s3 := make([]int, 3, 5)\n    fmt.Println(s3, len(s3), cap(s3))\n    // ---> [0 0 0] 3 5\n}\n```\n\n## 2.2 切片的访问\n\n- 当向切片中添加数据时，若添加的数量总和超过切片的容量，切片会自动扩容，且容量成倍增加\n- 切片扩容本质是指向了一个新的数组，原来的数组被系统自动回收\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\n\ts1 := make([]int, 0, 4)\n\tfmt.Printf(\"%v, %p\\n\", s1, s1)\n\tfmt.Printf(\"length:%d, capacity:%d\\n\", len(s1), cap(s1))\n    // ---> [], 0xc0000b2000\n\t// ---> length:0, capacity:4\n\n\ts1 = append(s1, 1, 2)\n\tfmt.Printf(\"%v, %p\\n\", s1, s1)\n\tfmt.Printf(\"length:%d, capacity:%d\\n\", len(s1), cap(s1))\n\t// ---> [1 2], 0xc0000b2000\n    // ---> length:2, capacity:4\n    // 添加元素未超过容量，内存地址不变，依然是原来的数组\n\n\ts1 = append(s1, 3, 4, 5)\n\tfmt.Printf(\"%v, %p\\n\", s1, s1)\n\tfmt.Printf(\"length:%d, capacity:%d\\n\", len(s1), cap(s1))\n    // ---> [1 2 3 4 5], 0xc0000b6000\n    // ---> length:5, capacity:8\n    // 添加元素超过容量，切片指向新的数组，容量成倍增加\n\n}\n```\n\n从数组创建切片类似 python 的切片操作，使用 `[a:b]`，前闭后开。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\n\ts1 := [8]int{1, 2, 3, 4, 5, 6, 7, 8}\n\ts2 := s1[:]\n\tfmt.Printf(\"%v, %p， %p\\n\", s2, &s1, s2)\n\tfmt.Println(len(s2), cap(s2))\n    // ---> [1 2 3 4 5 6 7 8], 0xc0000ae000， 0xc0000ae000\n\t// ---> 8 8\n\n\ts3 := s1[0:3]\n\tfmt.Printf(\"%v, %p, %p\\n\", s3, &s1, s3)\n\tfmt.Println(len(s3), cap(s3))\n\t// ---> [1 2 3], 0xc0000ae000, 0xc0000ae000\n\t// ---> 3 8\n\n\ts4 := s1[3:6]\n\tfmt.Printf(\"%v, %p, %p\\n\", s4, &s1, s4)\n\tfmt.Println(len(s4), cap(s4))\n    // ---> [4 5 6], 0xc0000ae000, 0xc0000ae018\n\t// ---> 3 5\n    // 切片的长度即为截取的数组的长度，容量是从截取起始位置到数组末尾的长度\n    // 数组的地址是数组中首个元素的地址，s4由于截取的起始索引为3，所以s4的地址与s1不同\n}\n```\n\n切片本质上是一种特殊的指针，存储的是底层数组的地址。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\n\ts1 := [8]int{1, 2, 3, 4, 5, 6, 7, 8}\n\ts2 := s1[:6]\n\ts1[0] = 100\n\tfmt.Printf(\"%p, %p\\n\", &s1, s2)\n\tfmt.Println(s1, s2)\n\t// ---> 0xc00001e140, 0xc00001e140\n\t// ---> [100 2 3 4 5 6 7 8] [100 2 3 4 5 6]\n    // 切片指向底层数组，底层数组改变，切片相应改变\n\n\ts2[3] = 50\n\tfmt.Printf(\"%p, %p\\n\", &s1, s2)\n\tfmt.Println(s1, s2)\n    // ---> 0xc00001e140, 0xc00001e140\n\t// ---> [100 2 3 50 5 6 7 8] [100 2 3 50 5 6]\n    // 切片改变，也会导致底层数组改变\n\n\ts2 = append(s2, 25)\n\tfmt.Printf(\"%p, %p\\n\", &s1, s2)\n\tfmt.Println(s1, s2)\n    // ---> 0xc00001e140, 0xc00001e140\n    // ---> [100 2 3 50 5 6 25 8] [100 2 3 50 5 6 25]\n\n}\n\n```\n\n切片是引用类型。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\n\ts1 := []int{1, 2, 3, 4}\n\ts2 := s1\n\tfmt.Println(s1, s2)\n\tfmt.Printf(\"s1底层数组的地址:%p, s1的地址:%p\\n\", &s1, s1)\n\tfmt.Printf(\"s2底层数组的地址:%p, s2的地址:%p\\n\", &s2, s2)\n    // ---> [1 2 3 4] [1 2 3 4]\n\t// ---> s1底层数组的地址:0xc00000c060, s1的地址:0xc0000144a0\n\t// ---> s2底层数组的地址:0xc00000c080, s2的地址:0xc0000144a0\n    // s1，s2指向同一个底层数组\n\n\ts1[0] = 100\n\tfmt.Println(s1, s2)\n\tfmt.Printf(\"s1底层数组的地址:%p, s1的地址:%p\\n\", &s1, s1)\n\tfmt.Printf(\"s2底层数组的地址:%p, s2的地址:%p\\n\", &s2, s2)\n    // ---> [100 2 3 4] [100 2 3 4]\n\t// ---> s1底层数组的地址:0xc00000c060, s1的地址:0xc0000144a0\n\t// ---> s2底层数组的地址:0xc00000c080, s2的地址:0xc0000144a0\n    // 改变s1，s2同时也会改变\n\n\ts2[3] = 50\n\tfmt.Println(s1, s2)\n\tfmt.Printf(\"s1底层数组的地址:%p, s1的地址:%p\\n\", &s1, s1)\n\tfmt.Printf(\"s2底层数组的地址:%p, s2的地址:%p\\n\", &s2, s2)\n    // ---> [100 2 3 50] [100 2 3 50]\n\t// ---> s1底层数组的地址:0xc00000c060, s1的地址:0xc0000144a0\n\t// ---> s2底层数组的地址:0xc00000c080, s2的地址:0xc0000144a0\n\t// 改变s2，s1同时也会改变\n}\n```\n\n# 3 map\n\n- map 类似于 python 中的字典，也是以键值对的方式存储数据\n- map 是引用类型\n- map 是可变的\n\n## 3.1 map 的定义\n\n```go\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    var m1 map[string]int\n\tfmt.Printf(\"%T, %v\\n\", m1, m1)\n    // ---> map[string]int, map[]\n\t// 这种定义方式，m1并未初始化，是nil类型，不能直接赋值\n\tm1[\"Jay\"] = 1\n    // ---> panic: assignment to entry in nil map\n\n\tvar m2 = map[string]int{\"Jay\": 1, \"Edison\": 2, \"Luffy\": 3}\n\tfmt.Printf(\"%T, %v\\n\", m2, m2)\n    // ---> map[string]int, map[Edison:2 Jay:1 Luffy:3]\n\n\tm3 := map[string]int{\"Jay\": 1, \"Edison\": 2, \"Luffy\": 3}\n\tfmt.Printf(\"%T, %v\\n\", m3, m3)\n    // ---> map[string]int, map[Edison:2 Jay:1 Luffy:3]\n\n    // 使用make函数\n\tm4 := make(map[string]int)\n\tfmt.Printf(\"%T, %v\\n\", m4, m4)\n    // ---> map[string]int, map[]\n}\n```\n\n## 3.2 map 的访问\n\nmap 使用 key 进行访问与赋值\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n    m5 := make(map[int]string)\n\tm5[1] = \"Jay\"\n\tm5[2] = \"Edison\"\n\tm5[3] = \"Luffy\"\n\tm5[4] = \"Perl\"\n\tm5[5] = \"Mads\"\n\tm5[6] = \"Joker\"\n\tfmt.Println(m5)\n    // map[1:Jay 2:Edison 3:Luffy 4:Perl 5:Mads 6:Joker]\n\n\tfmt.Println(m5[3])\n    // Luffy\n}\n```\n\n## 3.3 map 的遍历\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n    m6 := map[string]string{\"name\":\"Luffy\", \"sex\":\"male\", \"age\":\"18\", \"address\":\"East blue\"}\n\tfor k,v := range m6 {\n\t\tfmt.Printf(\"%s : %s\\n\", k, v)\n\t}\n}\n// ---> name : Luffy\n// ---> sex : male\n// ---> age : 18\n// ---> address : East blue\n```\n\n# 4 指针（pointer)\n\n指针是一种特殊的变量，用于保存另一变量的内存地址。\n\n## 4.1 指针的定义\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar p1 *[4]int\n\tfmt.Println(p1)\n    // ---> <nil> // <nil>表示空指针\n\ta := [4]int{1, 2, 3, 4}\n\tp1 = &a // &为取地址符\n\tfmt.Println(p1)\n    // ---> &[1 2 3 4]\n\tfmt.Printf(\"%p, %p\\n\", p1, &p1) // 第一个占位符表示p1保存的地址，第二个占位符表示p1自身的地址\n    // ---> 0xc0000b0000, 0xc0000a8018\n}\n```\n\n## 4.2 指针的访问\n\ngo 语言中使用 \\* 来取指针所保存的内存地址指向的变量值。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar p2 *[4]string\n\ta2 := [4]string {\"Luffy\", \"Hancock\", \"Zoro\", \"Nami\"}\n\n\tp2 = &a2\n\tfmt.Println(*p2)\n    // ---> [Luffy Hancock Zoro Nami]\n\n\t(*p2)[0] = \"Robin\"\n\tfmt.Println(p2)\n    // ---> &[Robin Hancock Zoro Nami]\n\tfmt.Println(a2)\n    // ---> [Robin Hancock Zoro Nami]\n\n\tp2[2] = \"Shanks\" // 简化写法\n\tfmt.Println(p2)\n    // ---> &[Robin Hancock Shanks Nami]\n\tfmt.Println(a2)\n    // ---> [Robin Hancock Shanks Nami]\n\n}\n```\n\n## 4.3 指针的指针\n\n指针的指针，顾名思义，该指针中保存的是另一个指针的地址。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tvar ptr *[4]int\n\tvar pptr **[4]int\n\n\ta := [4]int{1, 2, 3, 4}\n\tptr = &a\n\tpptr = &ptr\n\n\tfmt.Println(a)\n    // ---> [1 2 3 4]\n\tfmt.Println(ptr, *ptr)\n    // ---> &[1 2 3 4] [1 2 3 4]\n\tfmt.Println(pptr, *pptr)\n    // ---> 0xc0000a8018 &[1 2 3 4]\n}\n```\n\n# 5 函数\n\n- 函数是一种特殊的指针变量\n- 函数名指向函数体的内存地址\n- 函数名加 `()` 调用函数，执行函数体内的全部代码，并通过 `return` 语句将执行结果返回给函数调用处\n\n## 5.1 函数的定义\n\n```go\nfunc funcName(p1 type, p2 type)(v1 type, v2 type) {\n    // 函数体\n    return v1, v2\n}\n\n// eg:\nfunc add(num1, num2 int)int {\n    return num1+num2\n}\n```\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfmt.Printf(\"%T, %p\\n\", print, print)\n    // ---> func(), 0x48eb50 // 函数体的地址\n\n\tvar x func()\n\tx = print // 将print的值（函数体的地址）赋值给x\n\tx()\n    // ---> Nami is alse good!\n}\n\nfunc print() {\n\tfmt.Println(\"Nami is alse good!\")\n}\n```\n\n## 5.2 函数的参数\n\n### 5.2.1 可变参数\n\n- 可变参数本质上是一个切片\n- 在参数列表中，可变参数应放在最后\n- 可变参数至多只能有一个\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tadd1()\n    // ---> []int\n    // 可变参数实质上是一个slice\n\n\ts := []int{1, 2, 3, 4, 5, 6}\n\tx := add2(s...) // 使用...提取slice中的元素\n\tfmt.Println(x)\n    // ---> 21\n}\n\nfunc add1(num ...int) {\n\tfmt.Printf(\"%T\\n\", num)\n}\n\nfunc add2(num ...int) int {\n\tsum := 0\n\tfor _, v := range num {\n\t\tsum = sum + v\n\t}\n\n\treturn sum\n}\n```\n\n### 5.2.2 参数传递\n\n**值传递**，值传递传递的是参数的副本。值类型的数据默认都是值传递：基本数据类型、array、struct。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tarr := [4]int{1, 2, 3, 4}\n\tfmt.Printf(\"%p, %v\\n\", &arr, arr)\n    // ---> 0xc0000ae000, [1 2 3 4]\n\n\tchange(arr)\n    // ---> 0xc0000ae060\n\t// ---> [10000 2 3 4]\n\n    fmt.Println(arr)\n    // ---> [1 2 3 4]\n}\n\nfunc change(a [4]int) {\n\tfmt.Printf(\"%p\\n\", &a)\n\ta[0] = 10000\n\tfmt.Println(a)\n}\n```\n\n**引用传递**，引用传递传递的是参数的地址。引用类型的数据默认都是引用传递：slice、map、chan。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tslice := []int{1, 2, 3, 4}\n\tfmt.Println(slice)\n\t// ---> [1 2 3 4]\n\n\tchange(slice)\n    // ---> [10000 2 3 4]\n\n\tfmt.Println(slice)\n    // ---> [10000 2 3 4]\n}\n\nfunc change(s []int) {\n\ts[0] = 10000\n\tfmt.Println(s)\n}\n```\n\n## 5.3 递归函数\n\n```go\nfunc fibonacci(n int) int {\n\tif n == 1 || n == 2 {\n\t\treturn 1\n\t}\n\treturn fibonacci(n-1) + fibonacci(n-2)\n}\n```\n\n## 5.4 defer 语句\n\n`defer` 语句可以用来延迟一个函数或者方法的执行。当存在多个延迟调用时，它们被添加到一个堆栈中，遵循后进先出的原则执行。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tdefer print()\n\tdefer print2()\n\tfmt.Println(\"Hancock is good!\")\n    // ---> Hancock is good!\n    // ---> Robin is good! // LIFO\n    // ---> Nami is also good!\n}\n\nfunc print() {\n\tfmt.Println(\"Nami is also good!\")\n}\n\nfunc print2() {\n\tfmt.Println(\"Robin is good!\")\n}\n```\n\n## 5.5 匿名函数\n\n- 匿名函数可以作为另一个函数的参数，也叫回调函数\n- 匿名函数可以作为另一个函数的返回值，也叫闭包结构\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tfunc () {\n\t\tfmt.Println(\"Hancock!\")\n\t}()\n    // ---> Hancock!\n\n\tfun1 := func () {\n\t\tfmt.Println(\"Nami!\")\n\t}\n\tfun1()\n    // ---> Nami!\n\n\t// 带参数与返回值的匿名函数\n\tres := func (a, b int) int {\n\t\treturn a+b\n\t}(1, 2)\n\tfmt.Println(res)\n    // ---> 3\n}\n```\n\n作为一个函数参数的函数就叫做回调函数。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tres := opr(1, 2, add)\n\tfmt.Println(res)\n    // ---> 3\n}\n\nfunc add(a, b int) int {\n\treturn a + b\n}\n\nfunc opr(a, b int, fun func(int,int)int) int {\n\treturn fun(a, b)\n}\n```\n\n使用匿名函数作为回调函数。\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tadd := func(a, b int) int {\n\t\treturn a + b\n\t}\n\tres := opr(1, 2, add)\n\tfmt.Println(res)\n    // ---> 3\n\n\tres2 := opr(1, 2, func(a, b int) int {\n\t\treturn a + b\n\t})\n\tfmt.Println(res2)\n    // ---> 3\n}\n\nfunc opr(a, b int, fun func(int, int) int) int {\n\treturn fun(a, b)\n}\n```\n\n一个外层函数有内层函数，内层函数会操作外层函数的局部变量（外层函数的参数，或者外层函数定义的局部变量），并且该外层函数的返回值就是这个内层函数，那么这个内层函数和外层函数的局部变量就统称为闭包结构。\n\n闭包中局部变量的生命周期会发生改变。正常的局部变量会随着外层函数的调用而创建，随着外层函数的结束而销毁。但是闭包结构中外层函数的局部变量不会随着外层函数的结束而销毁，因为内层函数还要继续使用。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tfmt.Printf(\"%p\\n\", increment)\n    // ---> 0x48f0f0 // 函数名所指向的函数体的地址\n\tres1 := increment()\n\tfmt.Printf(\"%p, %p\\n\", res1, &res1)\n    // ---> 0x48f190, 0xc00000e030 // 内层函数体的地址， res1变量的地址\n\tfmt.Println(res1())\n    // ---> 1\n\tfmt.Println(res1())\n    // ---> 2\n\tfmt.Println(res1())\n    // ---> 3\n\n\tres2 := increment()\n\tfmt.Println(res2())\n    // ---> 1\n\tfmt.Println(res2())\n    // ---> 2\n\n\tfmt.Println(res1())\n    // ---> 4\n\n\tvar fun func() func() int\n\tfun = increment\n\tfmt.Printf(\"%p\\n\", fun)\n    // ---> 0x48f0f0\n\tfmt.Printf(\"%p\\n\", &fun)\n    // ---> 0xc00000e038\n\n\tfun2 := increment\n\tfmt.Printf(\"%p\\n\", fun2)\n    // ---> 0x48f0f0\n\tfmt.Printf(\"%p\\n\", &fun2)\n    // ---> 0xc00000e040\n\n}\n\nfunc increment() func() int {\n\ti := 0 //这个外层函数的局部变量，是内层函数的全局变量\n\treturn func() int {\n\t\ti++\n\t\treturn i\n\t}\n}\n```\n\n# 6 结构体\n\n- 结构体是一系列相同类型或不同类型的数据构成的集合\n- 结构体是由一个个成员变量构成的，这些成员变量也叫做结构体的字段\n- 结构体是可变的\n- 结构体是值类型\n\n## 6.1 结构体的定义\n\n```go\n// 结构体使用type和struct关键字来进行声明\ntype Person struct {\n    name string\n    sex string\n    age int\n    address string\n}\n```\n\n## 6.2 结构体的初始化与访问\n\n```go\n// 结构体使用.操作符来进行访问\n// 使用var关键字初始化\nvar P1 Person\np1.name = \"Jay\"\np1.sex = \"male\"\np1.age = \"41\"\np1.address = \"Taibei\"\n\n// 类似简短声明\np2 := Person{}\np2.name = \"Zoro\"\np2.sex = \"male\"\np2.age = \"20\"\np2.address = \"East Blue\"\n\n// 按照field:value的方式提供初始化的值\np3 := Person{\n    name ： \"Luffy\",\n    sex ： \"male\",\n    age ： 18,\n    address : \"East Blue\",\n}\n\n// 按照顺序提供初始化的值\np4 := Person{\"Hancock\", \"female\", 29, \"East Blue\"}\n```\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tp1 := Person{\n\t\tname:    \"Hancock\",\n\t\tsex:     \"female\",\n\t\tage:     29,\n\t\taddress: \"East Blue\",\n\t}\n\n\tfmt.Println(p1)\n    // ---> {Hancock female 29 East Blue}\n    // 结构体使用.操作符来进行访问\n\tp1.age = 31\n\tfmt.Println(p1)\n    // ---> {Hancock female 31 East Blue}\n}\n\ntype Person struct {\n\tname    string\n\tsex     string\n\tage     int\n\taddress string\n}\n```\n\n## 6.3 结构体指针\n\n```go\npackage main\n\nimport(\n\t\"fmt\"\n)\n\nfunc main() {\n\tp1 := Person {\n\t\tname : \"Hancock\",\n\t\tsex : \"female\",\n\t\tage : 29,\n\t\taddress : \"East Blue\",\n\t}\n\n\tvar pp1 *Person\n\tpp1 = &p1\n\tfmt.Printf(\"%p, %T\\n\", pp1, pp1)\n    // ---> 0xc0000240c0, *main.Person\n\tfmt.Println(*pp1)\n    // ---> {Hancock female 29 East Blue}\n\n\t// 使用指针修改数据\n\t(*pp1).name = \"Nami\"\n\tfmt.Println(pp1, p1)\n    // ---> &{Nami female 29 East Blue} {Nami female 29 East Blue}\n\t// 简写\n\tpp1.name = \"Robin\"\n\tfmt.Println(pp1, p1)\n    // ---> &{Robin female 29 East Blue} {Robin female 29 East Blue}\n\n    // 使用new函数创建指针\n    // new函数指向了新开辟的内存空间，里面存储的是0值\n    pp2 := new(Person)\n\tfmt.Printf(\"%T\\n\", pp2)\n    // ---> *main.Person\n\tfmt.Println(pp2)\n    // ---> &{  0 }\n\n\tpp2.name = \"Luffy\"\n\tpp2.sex = \"male\"\n\tpp2.age = 18\n\tpp2.address = \"East Blue\"\n\tfmt.Println(pp2)\n    // ---> &{Luffy male 18 East Blue}\n}\n\ntype Person struct {\n\tname string\n\tsex string\n\tage int\n\taddress string\n}\n```\n\n## 6.4 匿名结构体与匿名字段\n\n```go\npackage main\n\nimport(\n\t\"fmt\"\n)\n\nfunc main() {\n    // 匿名结构体\n\tp1 := struct {\n\t\tname string\n\t\tsex string\n\t\tage int\n\t\taddress string\n\t} {\n\t\tname : \"Hancock\",\n\t\tsex : \"female\",\n\t\tage : 29,\n\t\taddress : \"East Blue\",\n\t}\n\tfmt.Println(p1)\n    // ---> {Hancock female 29 East Blue}\n\n    // 结构体使用匿名字段时，默认使用字段类型作为field，因此字段类型不能重复\n\tp2 := Person {\"Hancock\", 29}\n\tfmt.Println(p2)\n\t// ---> {Hancock 29}\n\tfmt.Println(p2.string)\n    // ---> Hancock\n\n    // 同时使用匿名结构体和匿名字段\n\tp3 := struct {\n\t\tstring\n\t\tint\n\t} {\n\t\t\"Hancock\",\n\t\t29,\n\t}\n\tfmt.Println(p3)\n    // ---> {Hancock 29}\n\tfmt.Println(p3.string)\n    // ---> Hancock\n}\n\ntype Person struct {\n\tstring\n\tint\n}\n```\n\n## 6.5 结构体嵌套\n\n```go\npackage main\n\nimport(\n\t\"fmt\"\n)\n\nfunc main() {\n\tp1 := Person {\n\t\tname : Name {\n\t\t\tfirstName : \"Hancock\",\n\t\t\tlastName : \"Boa\",\n\t\t},\n\t\tsex : \"female\",\n\t\tage : 29,\n\t\taddress : \"East Blue\",\n\t}\n\n\tfmt.Printf(\"姓：%s，名：%s，性别：%s，年龄：%d，地址：%s\\n\", p1.name.lastName, p1.name.firstName, p1.sex, p1.age, p1.address)\n    // ---> 姓：Boa，名：Hancock，性别：female，年龄：29，地址：East Blue\n}\n\ntype Name struct {\n\tfirstName string\n\tlastName string\n}\n\ntype Person struct {\n\tname Name\n\tsex string\n\tage int\n\taddress string\n}\n```\n\n由于结构体是值类型，因此在嵌套时也可以选择嵌套结构体指针，可以保持数据的一致性，同时节省内存。\n\n```go\npackage main\n\nimport(\n\t\"fmt\"\n)\n\nfunc main() {\n\tn1 := Name {\n\t\tfirstName : \"Hancock\",\n\t\tlastName : \"Boa\",\n\t}\n\n\tp1 := Person {\n\t\tname : &n1,\n\t\tsex : \"female\",\n\t\tage : 29,\n\t\taddress : \"East Blue\",\n\t}\n\n\tfmt.Printf(\"姓：%s，名：%s，性别：%s，年龄：%d，地址：%s\\n\", p1.name.lastName, p1.name.firstName, p1.sex, p1.age, p1.address)\n    // ---> 姓：Boa，名：Hancock，性别：female，年龄：29，地址：East Blue\n\n\tp1.name.lastName = \"Monkey D\"\n\tfmt.Println(n1)\n    // 修改p1，n1同时改变，数据保持一致\n    // ---> {Hancock Monkey D}\n}\n\ntype Name struct {\n\tfirstName string\n\tlastName string\n}\n\ntype Person struct {\n\tname *Name // 传入指针\n\tsex string\n\tage int\n\taddress string\n}\n```\n\n假如说结构体中同时包含匿名字段与非匿名字段，特别的，当匿名字段为指针时，在实例化结构体时要给匿名字段加上字段名，且该字段名就是指针对应的类型，否则会报错 `mixture of field:value and value initializers` 。\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\thancock := Person{\n\t\tname:   \"Hancock\",\n\t\tage:    29,\n\t\tgender: \"female\",\n\t}\n\tvar han *Person = &hancock\n\thanworker := Worker{\n\t\tPerson: han, // 要用指针对应的类型作为字段名\n\t\tskill:  \"bj\",\n\t\tsalary: 200,\n\t}\n\n\tfmt.Println(hanworker)\n}\n\ntype Person struct {\n\tname   string\n\tage    int\n\tgender string\n}\n\ntype Worker struct {\n\t*Person\n\tskill  string\n\tsalary int\n}\n```"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"highlight-style":"zenburn","html-math-method":"katex","output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.6.34","theme":["cosmo","../../theme.scss"],"title-block-banner":true,"title":"Golang学习笔记","author":"Tom","date":"2020-02-03","code-block-bg":true,"categories":["Golang"],"image":"golang.png","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}