{"title":"Numpy Notes: Python data analysis","markdown":{"yaml":{"title":"Numpy Notes: Python data analysis","author":"Tom","date":"2021-09-20","toc":true,"number-sections":false,"highlight-style":"atom-one","code-block-bg":true,"categories":["数据分析"],"image":"numpy.png","code-fold":false,"html-math-method":"katex","jupyter":"python3"},"headingText":"1 ndarray","containsRefs":false,"markdown":"\n\nNumPy, short for Numerical Python, has such advantages:\n\n- Fast vectorized array operations for [data munging](https://www.experian.co.uk/business/glossary/data-munging/) and cleaning, subsetting and filtering, transformation, and any other kinds of computations\n- Common array algorithms like sorting, unique, and set operations\n- Efficient descriptive statistics and aggregating/summarizing data\n- Data alignment and relational data manipulations for merging and joining together heterogeneous datasets\n- Expressing conditional logic as array expressions instead of loops with `if-elif-else` branches\n- Group-wise data manipulations (aggregation, transformation, function application)\n\n[Pure Python leaves many details to runtime environment:](https://python-programming.quantecon.org/need_for_speed.html)\n\n- specifying variable types\n- memory allocation/deallocation, etc\n\n**NumPy is fast**. \n\n- NumPy internally stores data in a contiguous block of memory, independent of other built-in Python objects. NumPy's library of algorithms written in the C language can operate on this memory without any type checking or other overhead. NumPy arrays also use much less memory than built-in Python sequences. \n- NumPy operations perform complex computations on entire arrays without the need for Python `for` loops.\n\n\nAn ***ndarray*** (N dimensional array) is a generic multidimensional container for **homogeneous** data; that is, all of the elements must be the same type (free of type checking). Every array has a ***shape***, a tuple indicating the size of each dimension; a ***dtype***, an object describing the data type of the array; a ***ndim***, an integer indicating the dimension of the ndarray.\n\n## 1.1 Creating ndarrays\n\n### 1.1.1 `array` function. \n\n`array` function accepts any sequence-like object (list, list of lists, other arrays, etc) and produces a new NumPy array containing the passed data. **Unless explicitly specified, `np.array` tries to infer a good data type for the array that it creates**. The data type is stored in a special **dtype** metadata object.\n\n### 1.1.2 `zeros`,`ones`,`empty`,`arange` etc\n\nFunction|Description\n-|:-:\narray|Convert input data (list, tuple, array, or other sequence type) to an ndarray either by inferring a dtype or explicitly specifying a dtype; copies the input data by default\nasarray|Convert input to ndarray, but do not copy if the input is already an ndarray\narange|Like the built-in range but returns an ndarray instead of a list\nones|Produce an array of all 1s with the given shape and dtype\nones_like|Takes another array and produces a ones array of the same shape and dtype\nzeros|Like ones but producing arrays of 0s instead\nzeros_like|Like ones_like but producing arrays of 0s instead\nempty|Create new arrays by allocating new memory, but do not populate with any values\nempty_like|Like ones_like but do not populate with any values\nfull|Produce an array of the given shape and dtype with all values set to the indicated \"fill value\"\nfull_like|full_like takes another array and produces a filled array of the same shape and dtype\neye, identity|Create a square NxN identity matrix\n\n## 1.2 Data Types for ndarrays\n\nThe data type or ***dtype*** is a special object containing the information (or metadata, data about data) the ndarray needs to interpret a chunk of memory as a particular type of data. **In most cases dtype provide a mapping directly onto an  underlying disk or memory representation, which makes it easy to read and write binary streams of data to disk and also to connect to code written in a low-level language like C or Fortran.**\n\n## 1.3 Arithmetic with NumPy Arrays\n\n***Vectorization*** - Any arithmetic operations between equal-size arrays applies the operation element-wise.\n\n***Broadcasting*** - Operations between differently sized arrays.\n\n## 1.4 Basic Indexing and Slicing\n\nOne-dimensional array indexing and slicing act similarly to Python lists.\n\nArray slices are ***views*** on the original array, which means any modification to the view will be reflected in the source array. This design intends to obtain high performance and save memory.\n\nFor higher dimensional arrays, we can access every individual element recursively. First, indexing moves along axis 0 as the \"rows\" of the array and then axis 1 as the \"columns\".\n\n## 1.5 Boolean Indexing\n\nSelecting data from an array by boolean indexing always creates a **copy** of the data.\n\n## 1.6 Fancy Indexing\n\n- ***Fancy indexing*** is a term adopted by NumPy to describe indexing using integer arrays.\n- The result of fancy indexing is always one-dimensional.\n- Fancy indexing always copies the data into a new array.\n\n## 1.7 Transposing Arrays and Swapping Axes\n\nTransposing is a special form of reshaping that similiarly **returns a view on the underlying data without copying anything**. Arrays have the `transpose` method and also the special `T` attribute.\n\n# 2 Universal Functions\n\n***ufunc***, short for universal function, is a function that performs element-wise operations on data in ndarrays.\n\n# 3 Array-Oriented Programming with Arrays\n\n## 3.1 Expressing Conditional Logic as Array Operations\n\n## 3.2 Mathematical and Statiscal Methods\n\nA set of mathematical functions that compute statistics about an entire array or about the data along an axis are accessible as methods of the array class and the top-level NumPy function.\n\n## 3.3 Methods for Boolean Arrays\n\nBoolean values are coerced to 1 (True) and 0 (False) in the preceding methods. Thus, sum is often used as a means of counting True values in a boolean array.\n\nThere are two additional methods, `any` and `all`, useful especially for boolean arrays. `any` tests whether one or more values in an array is True, while `all` checks if every value is True.\n\n## 3.4 Sorting\n\nNumPy arrays can be **sorted in-place** with the `sort` method.\n\nWe can sort each one-dimensional section of values in a multidimensional array in-place along an axis by passing the axis number to sort.\n\nThe top-level method `np.sort` returns a sorted copy of an array instead of modifying the array in-place. A quick-and-dirty way to compute the quantiles of an array is to sort it and select the value at a particular rank.\n\n## 3.5 Unique and Other Set Logic\n","srcMarkdownNoYaml":"\n\nNumPy, short for Numerical Python, has such advantages:\n\n- Fast vectorized array operations for [data munging](https://www.experian.co.uk/business/glossary/data-munging/) and cleaning, subsetting and filtering, transformation, and any other kinds of computations\n- Common array algorithms like sorting, unique, and set operations\n- Efficient descriptive statistics and aggregating/summarizing data\n- Data alignment and relational data manipulations for merging and joining together heterogeneous datasets\n- Expressing conditional logic as array expressions instead of loops with `if-elif-else` branches\n- Group-wise data manipulations (aggregation, transformation, function application)\n\n[Pure Python leaves many details to runtime environment:](https://python-programming.quantecon.org/need_for_speed.html)\n\n- specifying variable types\n- memory allocation/deallocation, etc\n\n**NumPy is fast**. \n\n- NumPy internally stores data in a contiguous block of memory, independent of other built-in Python objects. NumPy's library of algorithms written in the C language can operate on this memory without any type checking or other overhead. NumPy arrays also use much less memory than built-in Python sequences. \n- NumPy operations perform complex computations on entire arrays without the need for Python `for` loops.\n\n# 1 ndarray\n\nAn ***ndarray*** (N dimensional array) is a generic multidimensional container for **homogeneous** data; that is, all of the elements must be the same type (free of type checking). Every array has a ***shape***, a tuple indicating the size of each dimension; a ***dtype***, an object describing the data type of the array; a ***ndim***, an integer indicating the dimension of the ndarray.\n\n## 1.1 Creating ndarrays\n\n### 1.1.1 `array` function. \n\n`array` function accepts any sequence-like object (list, list of lists, other arrays, etc) and produces a new NumPy array containing the passed data. **Unless explicitly specified, `np.array` tries to infer a good data type for the array that it creates**. The data type is stored in a special **dtype** metadata object.\n\n### 1.1.2 `zeros`,`ones`,`empty`,`arange` etc\n\nFunction|Description\n-|:-:\narray|Convert input data (list, tuple, array, or other sequence type) to an ndarray either by inferring a dtype or explicitly specifying a dtype; copies the input data by default\nasarray|Convert input to ndarray, but do not copy if the input is already an ndarray\narange|Like the built-in range but returns an ndarray instead of a list\nones|Produce an array of all 1s with the given shape and dtype\nones_like|Takes another array and produces a ones array of the same shape and dtype\nzeros|Like ones but producing arrays of 0s instead\nzeros_like|Like ones_like but producing arrays of 0s instead\nempty|Create new arrays by allocating new memory, but do not populate with any values\nempty_like|Like ones_like but do not populate with any values\nfull|Produce an array of the given shape and dtype with all values set to the indicated \"fill value\"\nfull_like|full_like takes another array and produces a filled array of the same shape and dtype\neye, identity|Create a square NxN identity matrix\n\n## 1.2 Data Types for ndarrays\n\nThe data type or ***dtype*** is a special object containing the information (or metadata, data about data) the ndarray needs to interpret a chunk of memory as a particular type of data. **In most cases dtype provide a mapping directly onto an  underlying disk or memory representation, which makes it easy to read and write binary streams of data to disk and also to connect to code written in a low-level language like C or Fortran.**\n\n## 1.3 Arithmetic with NumPy Arrays\n\n***Vectorization*** - Any arithmetic operations between equal-size arrays applies the operation element-wise.\n\n***Broadcasting*** - Operations between differently sized arrays.\n\n## 1.4 Basic Indexing and Slicing\n\nOne-dimensional array indexing and slicing act similarly to Python lists.\n\nArray slices are ***views*** on the original array, which means any modification to the view will be reflected in the source array. This design intends to obtain high performance and save memory.\n\nFor higher dimensional arrays, we can access every individual element recursively. First, indexing moves along axis 0 as the \"rows\" of the array and then axis 1 as the \"columns\".\n\n## 1.5 Boolean Indexing\n\nSelecting data from an array by boolean indexing always creates a **copy** of the data.\n\n## 1.6 Fancy Indexing\n\n- ***Fancy indexing*** is a term adopted by NumPy to describe indexing using integer arrays.\n- The result of fancy indexing is always one-dimensional.\n- Fancy indexing always copies the data into a new array.\n\n## 1.7 Transposing Arrays and Swapping Axes\n\nTransposing is a special form of reshaping that similiarly **returns a view on the underlying data without copying anything**. Arrays have the `transpose` method and also the special `T` attribute.\n\n# 2 Universal Functions\n\n***ufunc***, short for universal function, is a function that performs element-wise operations on data in ndarrays.\n\n# 3 Array-Oriented Programming with Arrays\n\n## 3.1 Expressing Conditional Logic as Array Operations\n\n## 3.2 Mathematical and Statiscal Methods\n\nA set of mathematical functions that compute statistics about an entire array or about the data along an axis are accessible as methods of the array class and the top-level NumPy function.\n\n## 3.3 Methods for Boolean Arrays\n\nBoolean values are coerced to 1 (True) and 0 (False) in the preceding methods. Thus, sum is often used as a means of counting True values in a boolean array.\n\nThere are two additional methods, `any` and `all`, useful especially for boolean arrays. `any` tests whether one or more values in an array is True, while `all` checks if every value is True.\n\n## 3.4 Sorting\n\nNumPy arrays can be **sorted in-place** with the `sort` method.\n\nWe can sort each one-dimensional section of values in a multidimensional array in-place along an axis by passing the axis number to sort.\n\nThe top-level method `np.sort` returns a sorted copy of an array instead of modifying the array in-place. A quick-and-dirty way to compute the quantiles of an array is to sort it and select the value at a particular rank.\n\n## 3.5 Unique and Other Set Logic\n"},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":true,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":false,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"jupyter"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":false,"code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"number-sections":false,"highlight-style":"atom-one","html-math-method":"katex","output-file":"index.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.5.56","theme":["cosmo","../../theme.scss"],"title-block-banner":true,"title":"Numpy Notes: Python data analysis","author":"Tom","date":"2021-09-20","code-block-bg":true,"categories":["数据分析"],"image":"numpy.png","jupyter":"python3"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}